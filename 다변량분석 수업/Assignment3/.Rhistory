library(glmnet)
library(GA)
library(tidyverse)
library(corrplot)
library(moments)
library(ggplot2)
library(Epi)
# Performance Evaluation Function -----------------------------------------
perf_eval <- function(cm){
# True positive rate: TPR (Recall)
TPR <- cm[2,2]/sum(cm[2,])
# Precision
PRE <- cm[2,2]/sum(cm[,2])
# True negative rate: TNR
TNR <- cm[1,1]/sum(cm[1,])
# Simple Accuracy
ACC <- (cm[1,1]+cm[2,2])/sum(cm)
# Balanced Correction Rate
BCR <- sqrt(TPR*TNR)
# F1-Measure
F1 <- 2*TPR*PRE/(TPR+PRE)
return(c(TPR, PRE, TNR, ACC, BCR, F1))
}
Perf_Table <- matrix(0, nrow = 8, ncol = 6)
rownames(Perf_Table) <- c("All", "Forward", "Backward", "Stepwise", "GA", "Ridge", "Lasso", "Elastic Net")
colnames(Perf_Table) <- c("TPR", "Precision", "TNR", "Accuracy", "BCR", "F1-Measure")
# Load the data & Preprocessing
Ploan <- read.csv("voice.csv")
Ploan$label <- ifelse(Ploan$label=="male",1,0)
Ploan_input <- Ploan[,-c(21)]
Ploan_input_scaled <- scale(Ploan_input, center = TRUE, scale = TRUE)
Ploan_target <- Ploan$label
Ploan_data_scaled <- data.frame(Ploan_input_scaled, Ploan_target)
set.seed(12345)
trn_idx <- sample(1:nrow(Ploan_data_scaled), round(0.7*nrow(Ploan_data_scaled)))
Ploan_trn <- Ploan_data_scaled[trn_idx,]
Ploan_tst <- Ploan_data_scaled[-trn_idx,]
# Variable selection method 0: Logistic Regression with all variables
start_time<-proc.time()
full_model <- glm(Ploan_target ~ ., family=binomial, Ploan_trn)
end_time<-proc.time()
end_time - start_time
summary(full_model)
full_model_coeff <- as.matrix(full_model$coefficients, 21, 1)
full_model_coeff
# Make prediction
full_model_prob <- predict(full_model, type = "response", newdata = Ploan_tst)
full_model_prey <- rep(0, nrow(Ploan_tst))
full_model_prey[which(full_model_prob >= 0.5)] <- 1
full_model_cm <- table(Ploan_tst$Ploan_target, full_model_prey)
full_model_cm
# Peformance evaluation
Perf_Table[1,] <- perf_eval(full_model_cm)
Perf_Table
#AUROC
#Training AUROC
t <-predict(full_model,Ploan_trn)
head(t)
ROC(test=t, stat=Ploan_trn$Ploan_target, plot='ROC', AUC=T, main="Trainset ROC")
#Training AUROC
t <-predict(full_model,Ploan_tst)
head(t)
ROC(test=t, stat=Ploan_tst$Ploan_target, plot='ROC', AUC=T, main="Validationset ROC")
# Variable selection method 1: Forward selection
tmp_x <- paste(colnames(Ploan_trn)[-21], collapse=" + ")
tmp_xy <- paste("Ploan_target ~ ", tmp_x, collapse = "")
as.formula(tmp_xy)
start_time<-proc.time()
forward_model <- step(glm(Ploan_target ~ 1, data = Ploan_trn),
scope = list(upper = as.formula(tmp_xy), lower = Ploan_target ~ 1),
direction="forward", trace = 1)
end_time<-proc.time()
end_time - start_time
summary(forward_model)
forward_model_coeff <- as.matrix(forward_model$coefficients, 21, 1)
forward_model_coeff
# Make prediction
forward_model_prob <- predict(forward_model, type = "response", newdata = Ploan_tst)
forward_model_prey <- rep(0, nrow(Ploan_tst))
forward_model_prey[which(forward_model_prob >= 0.5)] <- 1
forward_model_cm <- table(Ploan_tst$Ploan_target, forward_model_prey)
forward_model_cm
# Peformance evaluation
Perf_Table[2,] <- perf_eval(forward_model_cm)
Perf_Table
#AUROC
#Training AUROC
t <-predict(forward_model,Ploan_trn)
head(t)
ROC(test=t, stat=Ploan_trn$Ploan_target, plot='ROC', AUC=T, main="Trainset ROC")
#Training AUROC
t <-predict(forward_model,Ploan_tst)
head(t)
ROC(test=t, stat=Ploan_tst$Ploan_target, plot='ROC', AUC=T, main="Validationset ROC")
# Variable selection method 2: Backward elimination
start_time<-proc.time()
backward_model <- step(full_model,
scope = list(upper = as.formula(tmp_xy), lower = Ploan_target ~ 1),
direction = "backward", trace = 1)
end_time<-proc.time()
end_time - start_time
summary(backward_model)
backward_model_coeff <- as.matrix(backward_model$coefficients, 21, 1)
backward_model_coeff
# Make prediction
backward_model_prob <- predict(backward_model, type = "response", newdata = Ploan_tst)
backward_model_prey <- rep(0, nrow(Ploan_tst))
backward_model_prey[which(backward_model_prob >= 0.5)] <- 1
backward_model_cm <- table(Ploan_tst$Ploan_target, backward_model_prey)
backward_model_cm
# Peformance evaluation
Perf_Table[3,] <- perf_eval(backward_model_cm)
Perf_Table
#AUROC
#Training AUROC
t <-predict(backward_model,Ploan_trn)
head(t)
ROC(test=t, stat=Ploan_trn$Ploan_target, plot='ROC', AUC=T, main="Trainset ROC")
#Training AUROC
t <-predict(backward_model,Ploan_tst)
head(t)
ROC(test=t, stat=Ploan_tst$Ploan_target, plot='ROC', AUC=T, main="Validationset ROC")
# Variable selection method 3: Stepwise selection
tmp_x <- paste(colnames(Ploan_trn)[-21], collapse=" + ")
tmp_xy <- paste("Ploan_target ~ ", tmp_x, collapse = "")
as.formula(tmp_xy)
start_time<- proc.time()
stepwise_model <- step(glm(Ploan_target ~ 1, data = Ploan_trn),
scope = list(upper = as.formula(tmp_xy), lower = Ploan_target ~ 1),
direction="both", trace = 1)
end_time<-proc.time()
end_time - start_time
summary(stepwise_model)
stepwise_model_coeff <- as.matrix(stepwise_model$coefficients, 21, 1)
stepwise_model_coeff
# Make prediction
stepwise_model_prob <- predict(stepwise_model, type = "response", newdata = Ploan_tst)
stepwise_model_prey <- rep(0, nrow(Ploan_tst))
stepwise_model_prey[which(stepwise_model_prob >= 0.5)] <- 1
stepwise_model_cm <- table(Ploan_tst$Ploan_target, stepwise_model_prey)
stepwise_model_cm
# Peformance evaluation
Perf_Table[4,] <- perf_eval(stepwise_model_cm)
Perf_Table
#AUROC
#Training AUROC
t <-predict(stepwise_model,Ploan_trn)
head(t)
ROC(test=t, stat=Ploan_trn$Ploan_target, plot='ROC', AUC=T, main="Trainset ROC")
#Training AUROC
t <-predict(stepwise_model,Ploan_tst)
head(t)
ROC(test=t, stat=Ploan_tst$Ploan_target, plot='ROC', AUC=T, main="Validationset ROC")
library(glmnet)
library(GA)
perf_eval <- function(tgt_y, pre_y){
# RMSE
rmse <- sqrt(mean((tgt_y - pre_y)^2))
# MAE
mae <- mean(abs(tgt_y - pre_y))
# MAPE
mape <- 100*mean(abs((tgt_y - pre_y)/tgt_y))
return(c(rmse, mae, mape))
}
# Initialize a performance summary table
perf_mat <- matrix(0, nrow = 2, ncol = 3)
rownames(perf_mat) <-c("ë°ê¾¸ê¸° ì ","ë°ê¾¼ í")
colnames(perf_mat)<-c("RMSE","MAE","MAPE")
perf_mat
Perf_Table <- matrix(0, nrow = 8, ncol = 3)
rownames(Perf_Table) <- c("All", "Forward", "Backward", "Stepwise", "GA", "Ridge", "Lasso", "Elastic Net")
colnames(Perf_Table) <- c("RMSE","MAE","MAPE")
# Load the data & Preprocessing
Ploan <- read.csv("Concrete_Data.csv")
Ploan_input <- Ploan[,-c(9)]
Ploan_input_scaled <- scale(Ploan_input, center = TRUE, scale = TRUE)
Ploan_target <- Ploan$csMPa
Ploan_data_scaled <- data.frame(Ploan_input_scaled, Ploan_target)
# Split the data into the training/validation sets
set.seed(12345)
trn_idx <- sample(1:nrow(Ploan_data_scaled), round(0.7*nrow(Ploan_data_scaled)))
Ploan_trn <- Ploan_data_scaled[trn_idx,]
Ploan_tst <- Ploan_data_scaled[-trn_idx,]
# Variable selection method 0
full_model <- lm(Ploan_target ~ ., data = Ploan_trn)
summary(full_model)
full_model_coeff <- as.matrix(full_model$coefficients, 9, 1)
full_model_coeff
full_model_prey <- predict(full_model, newdata = Ploan_tst)
Perf_Table[1,] <- perf_eval(Ploan_tst$Ploan_target, full_model_prey)
