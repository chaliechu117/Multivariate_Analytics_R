# Dataset 1: insurance
insurance<- read.csv("kc_house_data.csv")
# Indices for the activated input variables
nCar <- nrow(insurance)
nVar <- ncol(insurance)
id_idx <- c(1,2)
#prepare data
insurance_mlr_data <- cbind(insurance[,-c(id_idx)])
# Split the data into the training/validation sets
set.seed(12345)
insurance_trn_idx <- sample(1:nCar, round(0.7*nCar))
insurance_trn_data <- insurance_mlr_data[insurance_trn_idx,]
insurance_val_data <- insurance_mlr_data[-insurance_trn_idx,]
# Train the MLR
mlr_insurance <- lm(charges ~ ., data = insurance_trn_data)
# Train the MLR
mlr_insurance <- lm(price ~ ., data = insurance_trn_data)
mlr_insurance
summary(mlr_insurance)
plot(mlr_insurance)
summary(mlr_insurance)
plot(mlr_insurance)
# Plot the result
plot(insurance_trn_data$charges, fitted(mlr_insurance),
xlim = c(4000,35000), ylim = c(4000,35000))
# Plot the result
plot(insurance_trn_data$price, fitted(mlr_insurance),
xlim = c(4000,35000), ylim = c(4000,35000))
abline(0,1,lty=3)
# Train the MLR
mlr_insurance <- lm(price ~ ., data = insurance_trn_data)
mlr_insurance
summary(mlr_insurance)
plot(mlr_insurance)
plot(insurance_trn_data$price, fitted(mlr_insurance),
xlim = c(4000,35000), ylim = c(4000,35000))
# Plot the result
plot(insurance_trn_data$price, fitted(mlr_insurance),
xlim = c(4000,35000), ylim = c(4000,35000))
abline(0,1,lty=3)
# normality test of residuals
insurance_resid <- resid(mlr_insurance)
m <- mean(insurance_resid)
std <- sqrt(var(insurance_resid))
m
std
hist(insurance_resid, density=20, breaks=50, prob=TRUE,
xlab="x-variable", main="normal curve over histogram")
curve(dnorm(x, mean=m, sd=std),
col="darkblue", lwd=2, add=TRUE, yaxt="n")
skewness(insurance_resid)
kurtosis(insurance_resid)
# Performance Measure
mlr_insurance_haty <- predict(mlr_insurance, newdata = insurance_val_data)
perf_mat[1,] <- perf_eval_reg(insurance_val_data$charges, mlr_insurance_haty)
perf_mat
perf_mat[1,] <- perf_eval_reg(insurance_val_data$price, mlr_insurance_haty)
perf_mat
library(moments)
perf_eval_reg <- function(tgt_y, pre_y){
# RMSE
rmse <- sqrt(mean((tgt_y - pre_y)^2))
# MAE
mae <- mean(abs(tgt_y - pre_y))
# MAPE
mape <- 100*mean(abs((tgt_y - pre_y)/tgt_y))
return(c(rmse, mae, mape))
}
# Initialize a performance summary table
perf_mat <- matrix(0, nrow = 1, ncol = 3)
rownames(perf_mat) <-c("insurance")
colnames(perf_mat)<-c("RMSE","MAE","MAPE")
perf_mat
# Dataset 1: insurance
insurance<- read.csv("insurance.csv")
# Indices for the activated input variables
nCar <- nrow(insurance)
nVar <- ncol(insurance)
View(insurance)
id_idx <- c(2)
category_idx <- c(5,6)
#smoker dummy
dummy_n <- rep(0,nCar)
dummy_y <- rep(0,nCar)
n_idx <- which(insurance$smoker == "no")
y_idx <- which(insurance$smoker == "yes")
dummy_n[n_idx] <- 1
dummy_y[y_idx] <- 1
smoke<-data.frame(dummy_n,dummy_y)
names(smoke)<-c("no","yes")
#region dummy
dummy_se <- rep(0,nCar)
dummy_sw <- rep(0,nCar)
dummy_ne <- rep(0,nCar)
dummy_nw <- rep(0,nCar)
se_idx <- which(insurance$region == "southeast")
sw_idx <- which(insurance$region == "southwest")
ne_idx <- which(insurance$region == "northeast")
nw_idx <- which(insurance$region == "northwest")
dummy_se[se_idx] <- 1
dummy_sw[sw_idx] <- 1
dummy_ne[ne_idx] <- 1
dummy_nw[nw_idx] <- 1
region <- data.frame(dummy_se, dummy_sw, dummy_ne,dummy_nw)
names(region) <- c("southeast","southwest","northeast","northwest")
#prepare data
insurance_mlr_data <- cbind(insurance[,-c(id_idx, category_idx)],c(smoke,region))
View(insurance_mlr_data)
# Split the data into the training/validation sets
set.seed(12345)
insurance_trn_idx <- sample(1:nCar, round(0.7*nCar))
insurance_trn_data <- insurance_mlr_data[insurance_trn_idx,]
insurance_val_data <- insurance_mlr_data[-insurance_trn_idx,]
# Train the MLR
mlr_insurance <- lm(charges ~ ., data = insurance_trn_data)
mlr_insurance
summary(mlr_insurance)
plot(mlr_insurance)
# Plot the result
plot(insurance_trn_data$price, fitted(mlr_insurance),
xlim = c(4000,35000), ylim = c(4000,35000))
# Plot the result
plot(insurance_trn_data$charges, fitted(mlr_insurance),
xlim = c(4000,35000), ylim = c(4000,35000))
abline(0,1,lty=3)
# normality test of residuals
insurance_resid <- resid(mlr_insurance)
m <- mean(insurance_resid)
std <- sqrt(var(insurance_resid))
hist(insurance_resid, density=20, breaks=50, prob=TRUE,
xlab="x-variable", main="normal curve over histogram")
curve(dnorm(x, mean=m, sd=std),
col="darkblue", lwd=2, add=TRUE, yaxt="n")
skewness(insurance_resid)
kurtosis(insurance_resid)
# Performance Measure
mlr_insurance_haty <- predict(mlr_insurance, newdata = insurance_val_data)
perf_mat[1,] <- perf_eval_reg(insurance_val_data$price, mlr_insurance_haty)
perf_mat
perf_mat[1,] <- perf_eval_reg(insurance_val_data$charges, mlr_insurance_haty)
perf_mat
# Dataset 1: insurance
insurance<- read.csv("Concrete_Data_Yeh.csv")
# Indices for the activated input variables
nCar <- nrow(insurance)
nVar <- ncol(insurance)
id_idx <- c(2)
category_idx <- c(5,6)
#더미 변수 만들기
#sex dummy
dummy_f <- rep(0,nCar)
# RMSE
rmse <- sqrt(mean((tgt_y - pre_y)^2))
perf_eval_reg <- function(tgt_y, pre_y){
# RMSE
rmse <- sqrt(mean((tgt_y - pre_y)^2))
# MAE
mae <- mean(abs(tgt_y - pre_y))
# MAPE
mape <- 100*mean(abs((tgt_y - pre_y)/tgt_y))
return(c(rmse, mae, mape))
}
# Initialize a performance summary table
perf_mat <- matrix(0, nrow = 1, ncol = 3)
rownames(perf_mat) <-c("insurance")
colnames(perf_mat)<-c("RMSE","MAE","MAPE")
perf_mat
# Dataset 1: insurance
insurance<- read.csv("Concrete_Data_Yeh.csv")
# Indices for the activated input variables
nCar <- nrow(insurance)
nVar <- ncol(insurance)
id_idx <- c(2)
# Dataset 1: insurance
insurance<- read.csv("Concrete_Data_Yeh.csv")
# Indices for the activated input variables
nCar <- nrow(insurance)
nVar <- ncol(insurance)
#prepare data
insurance_mlr_data <- cbind(insurance)
View(insurance_mlr_data)
# Split the data into the training/validation sets
set.seed(12345)
insurance_trn_idx <- sample(1:nCar, round(0.7*nCar))
insurance_trn_data <- insurance_mlr_data[insurance_trn_idx,]
insurance_val_data <- insurance_mlr_data[-insurance_trn_idx,]
# Train the MLR
mlr_insurance <- lm(csMPa ~ ., data = insurance_trn_data)
mlr_insurance
summary(mlr_insurance)
plot(mlr_insurance)
# Plot the result
plot(insurance_trn_data$charges, fitted(mlr_insurance),
xlim = c(4000,35000), ylim = c(4000,35000))
# Plot the result
plot(insurance_trn_data$csMPa, fitted(mlr_insurance),
xlim = c(4000,35000), ylim = c(4000,35000))
abline(0,1,lty=3)
# Plot the result
plot(insurance_trn_data$csMPa, fitted(mlr_insurance),
xlim = c(0,100), ylim = c(0,100))
abline(0,1,lty=3)
# normality test of residuals
insurance_resid <- resid(mlr_insurance)
m <- mean(insurance_resid)
std <- sqrt(var(insurance_resid))
m
std
hist(insurance_resid, density=20, breaks=50, prob=TRUE,
xlab="x-variable", main="normal curve over histogram")
curve(dnorm(x, mean=m, sd=std),
col="darkblue", lwd=2, add=TRUE, yaxt="n")
skewness(insurance_resid)
kurtosis(insurance_resid)
curve(dnorm(x, mean=m, sd=std),
col="darkblue", lwd=2, add=TRUE, yaxt="n")
skewness(insurance_resid)
kurtosis(insurance_resid)
# Performance Measure
mlr_insurance_haty <- predict(mlr_insurance, newdata = insurance_val_data)
perf_mat[1,] <- perf_eval_reg(insurance_val_data$csMPa, mlr_insurance_haty)
# Performance Measure
mlr_insurance_haty <- predict(mlr_insurance, newdata = insurance_val_data)
perf_mat[1,] <- perf_eval_reg(insurance_val_data$csMPa, mlr_insurance_haty)
perf_eval_reg <- function(tgt_y, pre_y){
# RMSE
rmse <- sqrt(mean((tgt_y - pre_y)^2))
# MAE
mae <- mean(abs(tgt_y - pre_y))
# MAPE
mape <- 100*mean(abs((tgt_y - pre_y)/tgt_y))
return(c(rmse, mae, mape))
}
# Initialize a performance summary table
perf_mat <- matrix(0, nrow = 1, ncol = 3)
rownames(perf_mat) <-c("insurance")
colnames(perf_mat)<-c("RMSE","MAE","MAPE")
perf_mat
perf_mat[1,] <- perf_eval_reg(insurance_val_data$csMPa, mlr_insurance_haty)
perf_mat
insurance<- read.csv("Concrete_Data_Yeh.csv")
boxplot(insurance$cement)
boxplot(insurance$cement)
boxplot(insurance$cement)
boxplot(insurance$cement)
boxplot(insurance$cement)
boxplot(insurance$cement)
boxplot(insurance$cement)
boxplot(insurance$cement)
boxplot(insurance$slag)
boxplot(insurance$flyash)
boxplot(insurance$water)
boxplot(insurance$superplasticizer)
boxplot(insurance$coarseaggregate)
boxplot(insurance$fineaggregate)
boxplot(insurance$age)
boxplot(insurance$csMPa)
qqnorm(insurance$cement)
qqline(insurance$cement)
mean(insurance$cement)
sd(insurance$cement)
skewness(insurance$cement)
kurtosis(insurance$cement)
#데이터 분석하기
boxplot(insurance$cement)
qqnorm(insurance$cement)
qqline(insurance$cement)
mean(insurance$cement)
sd(insurance$cement)
skewness(insurance$cement)
kurtosis(insurance$cement)
#데이터 분석하기
boxplot(insurance$cement)
qqnorm(insurance$cement)
qqline(insurance$cement)
#데이터 분석하기
boxplot(insurance$slag)
qqnorm(insurance$slag)
qqline(insurance$slag)
mean(insurance$slag)
sd(insurance$slag)
skewness(insurance$slag)
kurtosis(insurance$slag)
#데이터 분석하기
boxplot(insurance$flyash)
qqnorm(insurance$flyash)
#데이터 분석하기
boxplot(insurance$flyash)
qqnorm(insurance$flyash)
qqline(insurance$flyash)
mean(insurance$flyash)
sd(insurance$flyash)
skewness(insurance$flyash)
kurtosis(insurance$flyash)
#데이터 분석하기
boxplot(insurance$water)
qqnorm(insurance$water)
qqline(insurance$water)
mean(insurance$water)
sd(insurance$water)
skewness(insurance$water)
kurtosis(insurance$water)
#데이터 분석하기
boxplot(insurance$superplasticizer)
qqnorm(insurance$superplasticizer)
qqline(insurance$superplasticizer)
mean(insurance$superplasticizer)
sd(insurance$superplasticizer)
skewness(insurance$superplasticizer)
kurtosis(insurance$superplasticizer)
#데이터 분석하기
boxplot(insurance$coarseaggregate)
#데이터 분석하기
boxplot(insurance$coarseaggregate)
qqnorm(insurance$coarseaggregate)
qqline(insurance$coarseaggregate)
mean(insurance$coarseaggregate)
sd(insurance$coarseaggregate)
skewness(insurance$coarseaggregate)
kurtosis(insurance$coarseaggregate)
#데이터 분석하기
boxplot(insurance$fineaggregate)
qqnorm(insurance$fineaggregate)
qqline(insurance$fineaggregate)
mean(insurance$fineaggregate)
sd(insurance$fineaggregate)
skewness(insurance$fineaggregate)
kurtosis(insurance$fineaggregate)
library(tidyverse)
install.packages("tidyverse")
#이상치 데이터 삭제하기
summary(insurance$slag)
#이상치 데이터 삭제하기
summary(insurance$slag)
which(insurance$slag>summary(insurance$slag)[5] + 1.5*IQR(insurance$slag))
summary(insurance$water)
which(insurance$water>summary(insurance$water)[5] + 1.5*IQR(insurance$water))
which(insurance$water<summary(insurance$water)[5] + 1.5*IQR(insurance$water))
which(insurance$water<summary(insurance$water)[0] - 1.5*IQR(insurance$water))
which(insurance$water<summary(insurance$water)[0] + 1.5*IQR(insurance$water))
which(insurance$water<summary(insurance$water)[2] - 1.5*IQR(insurance$water))
which(insurance$water>summary(insurance$water)[5] + 1.5*IQR(insurance$water))
which(insurance$superplasticizer>summary(insurance$superplasticizer)[5] + 1.5*IQR(insurance$superplasticizer))
summary(insurance$superplasticizer)
which(insurance$superplasticizer>summary(insurance$superplasticizer)[5] + 1.5*IQR(insurance$superplasticizer))
summary(insurance$fineaggregate)
which(insurance$fineaggregate>summary(insurance$fineaggregate)[5] + 1.5*IQR(insurance$fineaggregate))
#이상치 데이터 삭제하기
summary(insurance$slag)
which(insurance$slag>summary(insurance$slag)[5] + 1.5*IQR(insurance$slag))
summary(insurance$water)
which(insurance$water>summary(insurance$water)[5] + 1.5*IQR(insurance$water))
which(insurance$water<summary(insurance$water)[2] - 1.5*IQR(insurance$water))
summary(insurance$superplasticizer)
which(insurance$superplasticizer>summary(insurance$superplasticizer)[5] + 1.5*IQR(insurance$superplasticizer))
summary(insurance$fineaggregate)
which(insurance$fineaggregate>summary(insurance$fineaggregate)[5] + 1.5*IQR(insurance$fineaggregate))
a<-which(insurance$slag>summary(insurance$slag)[5] + 1.5*IQR(insurance$slag))
b<-which(insurance$water>summary(insurance$water)[5] + 1.5*IQR(insurance$water))
c<-which(insurance$water<summary(insurance$water)[2] - 1.5*IQR(insurance$water))
d<-which(insurance$superplasticizer>summary(insurance$superplasticizer)[5] + 1.5*IQR(insurance$superplasticizer))
e<-which(insurance$fineaggregate>summary(insurance$fineaggregate)[5] + 1.5*IQR(insurance$fineaggregate))
insurance <- insurance[-c(a,b,c,d,e),]
summary(insurance$slag)
which(insurance$slag>summary(insurance$slag)[5] + 1.5*IQR(insurance$slag))
#확인
summary(insurance$slag)
which(insurance$slag>summary(insurance$slag)[5] + 1.5*IQR(insurance$slag))
summary(insurance$water)
which(insurance$water>summary(insurance$water)[5] + 1.5*IQR(insurance$water))
which(insurance$water<summary(insurance$water)[2] - 1.5*IQR(insurance$water))
View(insurance)
library(corrplot)
#상과관계
plot(insurance[,1:8])
#상과관계
plot(insurance[,1:8])
cor(insurance[,1:8])
x<-cor(insurance[,1:8])
corrplot(x)
x<-cor(insurance[,1:8])
corrplot(x)
cor(insurance[,1:8])
# Indices for the activated input variables
nCar <- nrow(insurance)
nVar <- ncol(insurance)
#prepare data
insurance_mlr_data <- cbind(insurance)
# Split the data into the training/validation sets
set.seed(12345)
insurance_trn_idx <- sample(1:nCar, round(0.7*nCar))
insurance_trn_data <- insurance_mlr_data[insurance_trn_idx,]
insurance_val_data <- insurance_mlr_data[-insurance_trn_idx,]
# Train the MLR
mlr_insurance <- lm(csMPa ~ ., data = insurance_trn_data)
mlr_insurance
summary(mlr_insurance)
plot(mlr_insurance)
# Plot the result
plot(insurance_trn_data$csMPa, fitted(mlr_insurance),
xlim = c(0,100), ylim = c(0,100))
abline(0,1,lty=3)
# normality test of residuals
insurance_resid <- resid(mlr_insurance)
m <- mean(insurance_resid)
std <- sqrt(var(insurance_resid))
hist(insurance_resid, density=20, breaks=50, prob=TRUE,
xlab="x-variable", main="normal curve over histogram")
curve(dnorm(x, mean=m, sd=std),
col="darkblue", lwd=2, add=TRUE, yaxt="n")
skewness(insurance_resid)
kurtosis(insurance_resid)
m
std
# Performance Measure
mlr_insurance_haty <- predict(mlr_insurance, newdata = insurance_val_data)
perf_mat[1,] <- perf_eval_reg(insurance_val_data$csMPa, mlr_insurance_haty)
perf_mat
#종속변수와 0.01유의미한 변수들 간의 상관관계
insurance_remake<-insurance <- insurance[-c(5,6,7),]
View(insurance_remake)
#종속변수와 0.01유의미한 변수들 간의 상관관계
insurance_remake<-insurance <- insurance[- ,c(5,6,7)]
#종속변수와 0.01유의미한 변수들 간의 상관관계
insurance_remake<- insurance[- ,c(5,6,7)]
#종속변수와 0.01유의미한 변수들 간의 상관관계
id_idx <-c(5,6,7)
#종속변수와 0.01유의미한 변수들 간의 상관관계
insurance_remake<- insurance[ ,-c(5,6,7)]
View(insurance_remake)
cor(insurance_remake[,6])
cor(insurance_remake[,1:6])
# Performance Measure
mlr_insurance_haty <- predict(mlr_insurance, newdata = insurance_val_data)
perf_mat[1,] <- perf_eval_reg(insurance_val_data$csMPa, mlr_insurance_haty)
perf_mat
insurance_remake2<-insurance[,c(1,2,4,5)]
View(insurance_remake2)
insurance_remake2<-insurance[,c(1,2,4,6)]
insurance_remake2<-insurance[,c(1,2,4,8)]
perf_eval_reg <- function(tgt_y, pre_y){
# RMSE
rmse <- sqrt(mean((tgt_y - pre_y)^2))
# MAE
mae <- mean(abs(tgt_y - pre_y))
# MAPE
mape <- 100*mean(abs((tgt_y - pre_y)/tgt_y))
return(c(rmse, mae, mape))
}
# Initialize a performance summary table
perf_mat <- matrix(0, nrow = 2, ncol = 3)
rownames(perf_mat) <-c("바꾸기 전","바꾼 후")
colnames(perf_mat)<-c("RMSE","MAE","MAPE")
perf_mat
# Performance Measure
mlr_insurance_haty <- predict(mlr_insurance, newdata = insurance_val_data)
perf_mat[1,] <- perf_eval_reg(insurance_val_data$csMPa, mlr_insurance_haty)
perf_mat
insurance_remake2<-insurance[,c(1,2,4,8,9)]
View(insurance_remake2)
#New model
insurance_remake2<-insurance[,c(1,2,4,8,9)]
# Indices for the activated input variables
nCar <- nrow(insurance_remake2)
nVar <- ncol(insurance_remake2)
#prepare data
insurance_remake2_mlr_data <- cbind(insurance_remake2)
# Split the data into the training/validation sets
set.seed(12345)
insurance_remake2_trn_idx <- sample(1:nCar, round(0.7*nCar))
insurance_remake2_trn_data <- insurance_remake2_mlr_data[insurance_remake2_trn_idx,]
insurance_remake2_val_data <- insurance_remake2_mlr_data[-insurance_remake2_trn_idx,]
# Train the MLR
mlr_insurance_remake2 <- lm(csMPa ~ ., data = insurance_remake2_trn_data)
mlr_insurance_remake2
summary(mlr_insurance_remake2)
plot(mlr_insurance_remake2)
mlr_insurance_remake2_haty <- predict(mlr_insurance_remake2, newdata = insurance_remake2_val_data)
perf_mat[2,] <- perf_eval_reg(insurance_remake2_val_data$csMPa, mlr_insurance_remake2_haty)
perf_mat
#requiring the Package
require(gam)
#requiring the Package
install.packages(gam)
#requiring the Package
install.packages('gam')
require(gam)
#ISLR package contains the 'Wage' Dataset
install.packages("ISLR")
require(ISLR)
attach(Wage) #Mid-Atlantic Wage Data
?Wage # To search more on the dataset
?gam() # To search on the gam function
a<-Wage
View(a)
gam1<-gam(wage~s(age,df=6)+s(year,df=6)+education ,data = Wage)
summary(gam1)
require(gam)
View(insurance_mlr_data)
View(insurance_remake2)
gam1<-gam(csMPa~s(cement,df=4)+s(slag,df=4)+s(water,df=4)+s(age,df=4) ,data = insurance_remake2)
summary(gam1)
par(mfrow=c(1,4))
plot(gam1,se = TRUE)
gam1<-gam(csMPa~cement+s(slag,df=4)+s(water,df=4)+s(age,df=4) ,data = insurance_remake2)
summary(gam1)
par(mfrow=c(1,4))
plot(gam1,se = TRUE)
gam1<-gam(csMPa~s(cement,df=4)+s(slag,df=4)+s(water,df=4)+s(age,df=4) ,data = insurance_remake2)
summary(gam1)
par(mfrow=c(1,4))
plot(gam1,se = TRUE)
